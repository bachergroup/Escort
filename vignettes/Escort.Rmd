---
title: "Escort"
author: "Xiaoru Dong"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Escort}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE, 
                      error = FALSE, 
                      fig.align = "center", 
                      dpi = 300)
```


```{r, warning=F, message=F}
library(Escort)
set.seed(11111)
```

# Introduction

`Escort` is an R package designed to assist users in detecting trajectories, evaluating and ranking various analysis choices. It follows a three-step approach, guiding users through the analysis process by offering goodness-of-fit evaluations for embeddings that represent a range of analysis choices. This encompasses features like feature selection, dimension reduction, and trajectory inference methods, along with their respective hyperparameters.


# Run Escort
After successful installation, `Escort` and related packages need be loaded into the working space:

```{r, results='hide', message=FALSE, warning=FALSE}
library(Escort)
library(parallelDist) # for fast calculation of the distance matrix.
library(cluster)
library(mclust)
library(RMTstat)
```


# Data 
In this vignette, I'll be using a simulated scRNA-seq dataset featuring a linear trajectory structure.

```{r, warning=FALSE, error=FALSE, message=FALSE}
load("data/step0_clean_dyntoy_L3.RData")
```

Escort employs a three-step approach to guide users through the analysis by detecting the presence of trajectories and then offering goodness-of-fit evaluations for both embeddings and trajectories. Embeddings are classified into two categories: recommended and non-recommended. Recommended embeddings indicate a better fit to the data and consequently, a better estimated trajectory.

## Step1: Detecting Trajectory Existence 

We identified two scenarios where trajectory fitting is not appropriate: when cells represent diverse cell types or when cells are homogeneous. The input in the step 1 is matrixes of raw and normalized single-cell RNA-seq data after quality control. The `HD_DCClusterscheck()` function is utilized to identify diverse cell types, while the `testHomogeneous()` function aids in assessing homogeneity

### Identifing distinct cell types
```{r, warning=FALSE, error=FALSE, message=FALSE}
dist_mat <- parallelDist::parDist(t(norm_counts), method = "manhattan")
LvsC <- HD_DCClusterscheck(dist_mat=dist_mat, rawcounts=rawcounts)
LvsC$DCcheck
```

### Assessing the homogeneity 
```{r, warning=FALSE, error=FALSE, message=FALSE}
cor_test <- testHomogeneous(norm_counts=norm_counts)
cor_test$decision
```

## Step 2: Evaluating the Characteristics of Embeddings
The second step is designed to identify preferred embeddings for performing trajectory inference. 

For feature selection, we could select any number of highly variable genes. Escort provides well-known dimension reduction algorithms for generating embeddings, such as UMAP, t-SNE, MDS, and PCA. For example, we apply the PCA algorithm, utilizing the top 20% of highly variable genes for the dimension reduction process. The `modelGeneVar()` function is employed here to identify highly variable genes.

```{r, warning=FALSE, error=FALSE, message=FALSE}
library(scran)
gene.var <- modelGeneVar(norm_counts)
genes.HVGs <- getTopHVGs(gene.var, prop=0.2)
dimred <- getDR_2D(norm_counts[genes.HVGs,], "PCA")
head(dimred)
```


### Examining cell connectivity on embeddings

We evaluate cell connectivity on the lower dimensional embedding using the `LD_DCClusterscheck()` function. Since distinct clusters have already been eliminated in step 1, then a reliable embedding should not exhibit distinct clusters. Thus, any embeddings found to be disconnected are classified immediately as not recommended. 

```{r, warning=FALSE, error=FALSE, message=FALSE}
DRLvsC <- LD_DCClusterscheck(dist_mat=dist(dimred, method = "euclidean"), DRdims=dimred, connectedCells = 1)
DRLvsC$DCcheck
```
### Examining preservation of cell relationships

We assess the effectiveness of low-dimensional embeddings in preserving inter-cellular relationships identified in the high-dimensional data by `Similaritycheck()` function. The percentage represents the rate at which cells in the low-dimensional embedding successfully maintain inter-cellular relationships. A higher percentage indicates a greater preservation of relationships among cells.

```{r, warning=FALSE, error=FALSE, message=FALSE}
simi_cells <- Similaritycheck(norm_counts=norm_counts, dimred=dimred, Cluters=LvsC)
simi_cells$GoodRate
```


### Examining cell density

A tighter distribution of cells in the embedding suggests an enhanced capacity to achieve high-quality trajectory fits. In this context, we compute the cell coverage rate as a representation of cell density by applying `GOFeval()` function.

```{r, warning=FALSE, error=FALSE, message=FALSE}
gof_eval <- GOFeval(dimred)
gof_eval$occupiedRate
```


## Step 3: Quantifying Trajectory Fitting Performance
Having evaluated the embeddings independently, the next step (step 3) involves assessing them within the framework of a trajectory inference method. When fitting a trajectory using a specific method, we identify the proportion of cells positioned along the trajectory with ambiguous projections. 

As an example, we use Slingshot for trajectory fitting.

```{r, warning=FALSE, error=FALSE, message=FALSE}
library(slingshot)
cls <- Mclust(dimred)$classification
ti_out <- slingshot(data=dimred, clusterLabels=cls)
rawpse <- slingPseudotime(ti_out, na=T)
ls_fitLine <- lapply(slingCurves(ti_out), function(x) x$s[x$ord,])

library(grDevices)
library(RColorBrewer)
colors <- colorRampPalette(brewer.pal(11,'Spectral')[-6])(100)
plotcol <- colors[cut(rawpse, breaks=100)]
plot(dimred, col = plotcol, pch=16, cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5)
lines(SlingshotDataSet(ti_out), lwd=2, col='black')
```

### Examining ambiguous cells

After fitting a trajectory, we use the `prepTraj()` function to generate an object that stores all relevant information about the embedding and trajectory. The fitted trajectory line is saved as segments between pairs of points within the `prepTraj()` function. Subsequently, the `UshapeDetector()` function is employed to calculate the proportion of ambiguous cells. For trajectories estimated to be smooth, such as those generated by Slingshot, it is recommended to use `outlierdetect='neutral'` in the `UshapeDetector()` function. Conversely, for convoluted trajectories like those produced by Monocle 3, it is suggested to use `outlierdetect='asymmetric'`. A smaller number of ambiguous cells indicates a more accurate estimation of pseudotime along the trajectory.

```{r, warning=FALSE, error=FALSE, message=FALSE}
fitLine <- do.call(rbind, lapply(ls_fitLine, function(x) {
  df_seg <- cbind(x[-nrow(x),],x[-1,])
  colnames(df_seg) <- c("x0", "y0", "x1", "y1")
  return(df_seg)
}))

obj <- prepTraj(dimred, PT=rawpse, fitLine=fitLine)

ushap_eval <- UshapeDetector(obj)
ushap_eval$Ambpct
```


## Scoring System
In the final step, a comprehensive score is computed to assess the overall performance of each embedding. This score encompasses four components evaluated in steps 2 and 3: cell connectivity (DCcheck), preservation of cell relationships (SimiRetain), cell density (GOF), and ambiguous cells (USHAPE). Results from these steps are stored in a data frame with columns: `DCcheck`, `SimiRetain`, `GOF`, and `USHAPE`. This data frame serves as input for the `score_cal()` function. Each embedding receives a score, indicating the recommended level for constructing a trajectory. Embeddings with a score greater than 0 are reported as recommended by Escort, while those with a score less than or equal to 0 are considered non-recommended.

```{r, warning=FALSE, error=FALSE, message=FALSE}
scoredf <- data.frame(DCcheck=DRLvsC$ifConnected, SimiRetain=simi_cells$GoodRate,
                      GOF=gof_eval$occupiedRate, USHAPE=ushap_eval$Ambpct)
score_cal(scoredf)
```

